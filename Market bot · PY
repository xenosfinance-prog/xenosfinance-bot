#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
IMPROVED Market Bot with aggressive rate limiting and fallback
Solves 429 errors and multiple instance conflicts
"""

import os
import time
import json
import logging
from datetime import datetime, timedelta
from typing import Dict, Optional
import asyncio

import yfinance as yf
from telegram import Update
from telegram.ext import Application, CommandHandler, ContextTypes

# ===== CONFIGURAZIONE =====
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Token e Chat ID
BOT_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')
CHAT_ID = os.getenv('TELEGRAM_CHAT_ID')

# CONFIGURAZIONE RATE LIMITING AGGRESSIVA
UPDATE_INTERVAL_HOURS = 4
DELAY_BETWEEN_SYMBOLS = 8  # 8 secondi tra simboli (era 4)
BATCH_SIZE = 5  # 5 simboli per batch (era 8)
BATCH_DELAY = 180  # 3 minuti tra batch (era 90 secondi)
MAX_RETRIES = 2  # Ridotto a 2 retry
RETRY_DELAY = 120  # 2 minuti tra retry

CACHE_FILE = 'market_cache.json'

# ===== SIMBOLI (RIDOTTI PER EVITARE RATE LIMIT) =====
MARKET_SYMBOLS = {
    'Futures Indici': {
        'ES=F': 'S&P 500',
        'NQ=F': 'Nasdaq 100',
        'YM=F': 'Dow Jones',
    },
    'Materie Prime': {
        'GC=F': 'Oro',
        'CL=F': 'Petrolio WTI',
        'NG=F': 'Gas Naturale',
    },
    'Crypto': {
        'BTC-USD': 'Bitcoin',
        'ETH-USD': 'Ethereum',
    },
    'Forex': {
        'EURUSD=X': 'EUR/USD',
        'GBPUSD=X': 'GBP/USD',
    }
}


# ===== CACHE =====
def load_cache() -> Dict:
    try:
        if os.path.exists(CACHE_FILE):
            with open(CACHE_FILE, 'r') as f:
                return json.load(f)
    except Exception as e:
        logger.error(f"Cache load error: {e}")
    return {}


def save_cache(data: Dict):
    try:
        data['_last_update'] = datetime.now().isoformat()
        with open(CACHE_FILE, 'w') as f:
            json.dump(data, f, indent=2)
        logger.info("‚úÖ Cache saved")
    except Exception as e:
        logger.error(f"Cache save error: {e}")


def is_cache_valid(cache: Dict, hours: int = UPDATE_INTERVAL_HOURS) -> bool:
    if not cache or '_last_update' not in cache:
        return False
    try:
        last_update = datetime.fromisoformat(cache['_last_update'])
        age = datetime.now() - last_update
        is_valid = age < timedelta(hours=hours)
        if is_valid:
            remaining = hours * 3600 - age.total_seconds()
            logger.info(f"‚úÖ Cache valid - {remaining/60:.1f} minutes remaining")
        return is_valid
    except:
        return False


# ===== FETCH CON RETRY AGGRESSIVO =====
def safe_fetch_price(symbol: str) -> Optional[Dict]:
    """
    Fetch con metodo semplificato e fallback multipli
    """
    logger.info(f"  üìä Fetching {symbol}...")
    
    for attempt in range(MAX_RETRIES):
        try:
            ticker = yf.Ticker(symbol)
            
            # Metodo 1: history (pi√π affidabile)
            try:
                hist = ticker.history(period='2d', timeout=15)
                if not hist.empty and len(hist) >= 1:
                    current = float(hist['Close'].iloc[-1])
                    
                    # Calcola change se abbiamo 2 giorni di dati
                    if len(hist) >= 2:
                        prev = float(hist['Close'].iloc[-2])
                        change = current - prev
                        change_pct = (change / prev * 100) if prev != 0 else 0
                    else:
                        change = 0
                        change_pct = 0
                    
                    logger.info(f"    ‚úÖ {symbol}: ${current:.2f} ({change_pct:+.2f}%)")
                    return {
                        'price': current,
                        'change': change,
                        'change_percent': change_pct,
                        'timestamp': datetime.now().isoformat(),
                        'method': 'history'
                    }
            except Exception as e:
                logger.debug(f"    History method failed for {symbol}: {e}")
            
            # Metodo 2: fast_info (fallback)
            try:
                info = ticker.fast_info
                if hasattr(info, 'last_price') and info.last_price:
                    price = float(info.last_price)
                    logger.info(f"    ‚úÖ {symbol}: ${price:.2f} (fast_info)")
                    return {
                        'price': price,
                        'change': 0,
                        'change_percent': 0,
                        'timestamp': datetime.now().isoformat(),
                        'method': 'fast_info'
                    }
            except Exception as e:
                logger.debug(f"    Fast_info method failed for {symbol}: {e}")
            
        except Exception as e:
            logger.warning(f"    ‚ö†Ô∏è  Attempt {attempt + 1}/{MAX_RETRIES} failed for {symbol}: {str(e)[:100]}")
            
            if attempt < MAX_RETRIES - 1:
                wait = RETRY_DELAY * (attempt + 1)
                logger.info(f"    ‚è≥ Waiting {wait}s before retry...")
                time.sleep(wait)
    
    logger.error(f"    ‚ùå {symbol}: All attempts failed")
    return None


# ===== AGGIORNAMENTO MERCATI =====
def update_all_markets() -> Dict:
    """
    Aggiorna tutti i mercati con RATE LIMITING AGGRESSIVO
    """
    logger.info("\n" + "="*60)
    logger.info("üîÑ STARTING MARKET UPDATE")
    logger.info("="*60)
    
    all_data = {}
    total_symbols = sum(len(symbols) for symbols in MARKET_SYMBOLS.values())
    current_count = 0
    
    for category, symbols in MARKET_SYMBOLS.items():
        logger.info(f"\nüìÇ Category: {category}")
        all_data[category] = {}
        
        symbol_list = list(symbols.items())
        
        # Processa in batch
        for batch_idx in range(0, len(symbol_list), BATCH_SIZE):
            batch = symbol_list[batch_idx:batch_idx + BATCH_SIZE]
            batch_num = batch_idx // BATCH_SIZE + 1
            total_batches = (len(symbol_list) + BATCH_SIZE - 1) // BATCH_SIZE
            
            logger.info(f"\n  üì¶ Batch {batch_num}/{total_batches} ({len(batch)} symbols)")
            
            for symbol, name in batch:
                current_count += 1
                logger.info(f"\n  [{current_count}/{total_symbols}] {name}")
                
                data = safe_fetch_price(symbol)
                
                if data:
                    all_data[category][symbol] = {'name': name, **data}
                else:
                    # Prova a usare dati dalla cache se disponibili
                    cache = load_cache()
                    if category in cache and symbol in cache[category]:
                        cached_data = cache[category][symbol]
                        logger.info(f"    üì¶ Using cached data for {symbol}")
                        all_data[category][symbol] = {
                            'name': name,
                            **cached_data,
                            'from_cache': True
                        }
                    else:
                        all_data[category][symbol] = {
                            'name': name,
                            'price': None,
                            'error': 'Data unavailable'
                        }
                
                # Delay tra simboli (IMPORTANTE!)
                if current_count < total_symbols:
                    logger.info(f"    ‚è∏Ô∏è  Waiting {DELAY_BETWEEN_SYMBOLS}s...")
                    time.sleep(DELAY_BETWEEN_SYMBOLS)
            
            # Delay LUNGO tra batch
            if batch_idx + BATCH_SIZE < len(symbol_list):
                logger.info(f"\n  üõë BATCH BREAK: Waiting {BATCH_DELAY}s before next batch...")
                time.sleep(BATCH_DELAY)
    
    logger.info("\n" + "="*60)
    logger.info("‚úÖ MARKET UPDATE COMPLETED")
    logger.info("="*60 + "\n")
    
    return all_data


# ===== FORMATTAZIONE =====
def format_message(data: Dict) -> str:
    parts = ["üìä <b>AGGIORNAMENTO MERCATI</b>\n"]
    parts.append(f"üïê {datetime.now().strftime('%d/%m/%Y %H:%M')}\n")
    
    for category, symbols in data.items():
        if category.startswith('_'):
            continue
        
        parts.append(f"\n<b>‚îÅ‚îÅ‚îÅ {category.upper()} ‚îÅ‚îÅ‚îÅ</b>")
        
        for symbol, info in symbols.items():
            name = info.get('name', symbol)
            price = info.get('price')
            
            if price is None:
                cached = " üì¶" if info.get('from_cache') else ""
                parts.append(f"‚ö™ {name}: <i>Non disponibile{cached}</i>")
                continue
            
            change_pct = info.get('change_percent', 0)
            emoji = "üü¢" if change_pct > 0 else "üî¥" if change_pct < 0 else "‚ö™"
            sign = "+" if change_pct > 0 else ""
            cached = " üì¶" if info.get('from_cache') else ""
            
            if price < 1:
                price_str = f"${price:.4f}"
            elif price < 100:
                price_str = f"${price:.2f}"
            else:
                price_str = f"${price:,.2f}"
            
            parts.append(f"{emoji} <b>{name}</b>{cached}\n   {price_str} ({sign}{change_pct:.2f}%)")
    
    parts.append(f"\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ")
    parts.append(f"Prossimo: {UPDATE_INTERVAL_HOURS}h | üì¶ = Cached")
    
    return "\n".join(parts)


# ===== COMANDI =====
async def cmd_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "üëã <b>Market Bot Attivo</b>\n\n"
        "Comandi:\n"
        "/update - Aggiornamento immediato\n"
        "/status - Stato bot\n"
        "/markets - Lista mercati\n\n"
        f"‚è∞ Auto-update ogni {UPDATE_INTERVAL_HOURS}h",
        parse_mode='HTML'
    )


async def cmd_status(update: Update, context: ContextTypes.DEFAULT_TYPE):
    cache = load_cache()
    
    if is_cache_valid(cache):
        last = datetime.fromisoformat(cache['_last_update'])
        next_update = last + timedelta(hours=UPDATE_INTERVAL_HOURS)
        delta = next_update - datetime.now()
        
        h = int(delta.total_seconds() // 3600)
        m = int((delta.total_seconds() % 3600) // 60)
        
        msg = (
            f"‚úÖ <b>Bot Attivo</b>\n\n"
            f"üìÖ Ultimo: {last.strftime('%d/%m %H:%M')}\n"
            f"‚è∞ Prossimo: {h}h {m}m\n"
            f"üîÑ Intervallo: {UPDATE_INTERVAL_HOURS}h"
        )
    else:
        msg = "‚ö†Ô∏è Cache non valida\nUsa /update"
    
    await update.message.reply_text(msg, parse_mode='HTML')


async def cmd_markets(update: Update, context: ContextTypes.DEFAULT_TYPE):
    parts = ["üìã <b>MERCATI MONITORATI</b>\n"]
    total = 0
    
    for cat, syms in MARKET_SYMBOLS.items():
        parts.append(f"\n<b>{cat}</b> ({len(syms)})")
        for sym, name in syms.items():
            parts.append(f"  ‚Ä¢ {name}")
            total += 1
    
    parts.append(f"\n<b>Totale: {total}</b>")
    await update.message.reply_text("\n".join(parts), parse_mode='HTML')


async def cmd_update(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "üîÑ Aggiornamento in corso...\n"
        f"‚è±Ô∏è Tempo stimato: ~{(sum(len(s) for s in MARKET_SYMBOLS.values()) * DELAY_BETWEEN_SYMBOLS)//60} minuti"
    )
    
    try:
        data = update_all_markets()
        save_cache(data)
        msg = format_message(data)
        await update.message.reply_text(msg, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Update error: {e}")
        await update.message.reply_text(f"‚ùå Errore: {str(e)[:200]}")


# ===== SCHEDULED UPDATE =====
async def scheduled_update(context: ContextTypes.DEFAULT_TYPE):
    logger.info("\n‚è∞ SCHEDULED UPDATE TRIGGERED")
    
    try:
        # Verifica cache
        cache = load_cache()
        if is_cache_valid(cache):
            logger.info("‚úÖ Cache still valid, skipping update")
            return
        
        logger.info("üîÑ Cache expired, starting update...")
        data = update_all_markets()
        save_cache(data)
        
        msg = format_message(data)
        await context.bot.send_message(chat_id=CHAT_ID, text=msg, parse_mode='HTML')
        
        logger.info("‚úÖ Scheduled update sent successfully")
        
    except Exception as e:
        logger.error(f"‚ùå Scheduled update error: {e}")
        try:
            await context.bot.send_message(
                chat_id=CHAT_ID,
                text=f"‚ö†Ô∏è Errore aggiornamento:\n{str(e)[:200]}"
            )
        except:
            pass


# ===== MAIN =====
def main():
    logger.info("\n" + "="*60)
    logger.info("üöÄ MARKET BOT STARTING (IMPROVED VERSION)")
    logger.info("="*60)
    
    if not BOT_TOKEN or not CHAT_ID:
        logger.error("‚ùå Missing BOT_TOKEN or CHAT_ID!")
        return
    
    logger.info(f"‚úÖ Token: {BOT_TOKEN[:10]}...")
    logger.info(f"‚úÖ Chat ID: {CHAT_ID}")
    logger.info(f"‚è±Ô∏è  Update interval: {UPDATE_INTERVAL_HOURS}h")
    logger.info(f"‚è±Ô∏è  Symbol delay: {DELAY_BETWEEN_SYMBOLS}s")
    logger.info(f"‚è±Ô∏è  Batch delay: {BATCH_DELAY}s")
    logger.info(f"üìä Total symbols: {sum(len(s) for s in MARKET_SYMBOLS.values())}")
    
    # Crea applicazione
    application = Application.builder().token(BOT_TOKEN).build()
    
    # Comandi
    application.add_handler(CommandHandler("start", cmd_start))
    application.add_handler(CommandHandler("status", cmd_status))
    application.add_handler(CommandHandler("markets", cmd_markets))
    application.add_handler(CommandHandler("update", cmd_update))
    
    # Job scheduler
    job_queue = application.job_queue
    job_queue.run_repeating(
        scheduled_update,
        interval=UPDATE_INTERVAL_HOURS * 3600,
        first=30  # Primo update dopo 30 secondi
    )
    
    logger.info("‚úÖ Bot configured")
    logger.info("="*60 + "\n")
    
    # Start polling
    application.run_polling(
        allowed_updates=Update.ALL_TYPES,
        drop_pending_updates=True  # IMPORTANTE: ignora update vecchi
    )


if __name__ == '__main__':
    main()
