#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
HYBRID MARKET BOT - Multiple API Sources
Evita rate limiting usando diverse API per diversi mercati
"""

import os
import time
import json
import logging
from datetime import datetime, timedelta
from typing import Dict, Optional
import requests

from telegram import Update
from telegram.ext import Application, CommandHandler, ContextTypes

# ===== CONFIG =====
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

BOT_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')
CHAT_ID = os.getenv('TELEGRAM_CHAT_ID')

UPDATE_INTERVAL_HOURS = 4
CACHE_FILE = 'market_cache.json'

# ===== API KEYS (opzionali - funziona anche senza) =====
# Registrati su alphavantage.co per chiave gratis (opzionale)
ALPHA_VANTAGE_KEY = os.getenv('ALPHA_VANTAGE_KEY', 'demo')

# ===== SIMBOLI RIDOTTI =====
# IMPORTANTE: Inizia con pochi simboli, poi aggiungi gradualmente
MARKET_SYMBOLS = {
    'Crypto': {
        'bitcoin': 'Bitcoin',
        'ethereum': 'Ethereum',
        'solana': 'Solana',
    },
    'Forex (USD)': {
        'eur': 'EUR/USD',
        'gbp': 'GBP/USD',
        'jpy': 'USD/JPY',
    }
}


# ===== CACHE =====
def load_cache() -> Dict:
    try:
        if os.path.exists(CACHE_FILE):
            with open(CACHE_FILE, 'r') as f:
                return json.load(f)
    except:
        pass
    return {}


def save_cache(data: Dict):
    try:
        data['_last_update'] = datetime.now().isoformat()
        with open(CACHE_FILE, 'w') as f:
            json.dump(data, f, indent=2)
        logger.info("âœ… Cache saved")
    except Exception as e:
        logger.error(f"Cache save error: {e}")


def is_cache_valid(cache: Dict, hours: int = UPDATE_INTERVAL_HOURS) -> bool:
    if not cache or '_last_update' not in cache:
        return False
    try:
        last = datetime.fromisoformat(cache['_last_update'])
        return datetime.now() - last < timedelta(hours=hours)
    except:
        return False


# ===== API FETCHERS =====

def fetch_crypto_coingecko(coin_id: str) -> Optional[Dict]:
    """
    Usa CoinGecko API (GRATUITA, no rate limit aggressivo)
    """
    try:
        url = 'https://api.coingecko.com/api/v3/simple/price'
        params = {
            'ids': coin_id,
            'vs_currencies': 'usd',
            'include_24hr_change': 'true'
        }
        
        response = requests.get(url, params=params, timeout=10)
        response.raise_for_status()
        data = response.json()
        
        if coin_id in data:
            return {
                'price': data[coin_id]['usd'],
                'change_percent': data[coin_id].get('usd_24h_change', 0),
                'source': 'CoinGecko'
            }
    except Exception as e:
        logger.error(f"CoinGecko error for {coin_id}: {e}")
    
    return None


def fetch_forex_exchangerate(base: str) -> Optional[Dict]:
    """
    Usa ExchangeRate-API (GRATUITO)
    """
    try:
        url = f'https://api.exchangerate-api.com/v4/latest/{base.upper()}'
        response = requests.get(url, timeout=10)
        response.raise_for_status()
        data = response.json()
        
        if 'rates' in data and 'USD' in data['rates']:
            rate = data['rates']['USD']
            return {
                'price': rate,
                'change_percent': 0,  # Questa API non fornisce variazioni
                'source': 'ExchangeRate-API'
            }
    except Exception as e:
        logger.error(f"ExchangeRate error for {base}: {e}")
    
    return None


def fetch_forex_fixer(base: str) -> Optional[Dict]:
    """
    Usa Fixer.io come fallback (richiede registrazione gratuita)
    """
    try:
        # Alternativa semplice: converti USD vs altre valute
        currencies = {
            'eur': 'EUR',
            'gbp': 'GBP',
            'jpy': 'JPY',
            'aud': 'AUD',
            'cad': 'CAD'
        }
        
        if base.lower() not in currencies:
            return None
        
        currency = currencies[base.lower()]
        
        # Usa un'API pubblica alternativa
        url = f'https://open.er-api.com/v6/latest/USD'
        response = requests.get(url, timeout=10)
        response.raise_for_status()
        data = response.json()
        
        if 'rates' in data and currency in data['rates']:
            # Per EUR/USD, GBP/USD invertiamo il rate
            # Per USD/JPY usiamo diretto
            if currency in ['EUR', 'GBP', 'AUD']:
                rate = 1 / data['rates'][currency]
            else:
                rate = data['rates'][currency]
            
            return {
                'price': rate,
                'change_percent': 0,
                'source': 'ER-API'
            }
    except Exception as e:
        logger.error(f"ER-API error for {base}: {e}")
    
    return None


# ===== AGGIORNAMENTO MERCATI =====
def update_all_markets() -> Dict:
    """
    Aggiorna mercati usando API diverse
    """
    logger.info("\n" + "="*60)
    logger.info("ğŸ”„ MARKET UPDATE (HYBRID MODE)")
    logger.info("="*60)
    
    all_data = {}
    
    # CRYPTO con CoinGecko
    if 'Crypto' in MARKET_SYMBOLS:
        logger.info("\nğŸ“Š Fetching Crypto (CoinGecko)...")
        all_data['Crypto'] = {}
        
        for coin_id, name in MARKET_SYMBOLS['Crypto'].items():
            logger.info(f"  {name}...")
            data = fetch_crypto_coingecko(coin_id)
            
            if data:
                all_data['Crypto'][coin_id] = {'name': name, **data}
                logger.info(f"    âœ… ${data['price']:,.2f} ({data['change_percent']:+.2f}%)")
            else:
                all_data['Crypto'][coin_id] = {
                    'name': name,
                    'price': None,
                    'error': 'Unavailable'
                }
                logger.warning(f"    âŒ Failed")
            
            time.sleep(2)  # Pausa tra richieste
    
    # FOREX
    if 'Forex (USD)' in MARKET_SYMBOLS:
        logger.info("\nğŸ’± Fetching Forex...")
        all_data['Forex (USD)'] = {}
        
        for base, name in MARKET_SYMBOLS['Forex (USD)'].items():
            logger.info(f"  {name}...")
            
            # Prova prima ExchangeRate
            data = fetch_forex_exchangerate(base)
            
            # Se fallisce, prova ER-API
            if not data:
                data = fetch_forex_fixer(base)
            
            if data:
                all_data['Forex (USD)'][base] = {'name': name, **data}
                logger.info(f"    âœ… {data['price']:.4f}")
            else:
                all_data['Forex (USD)'][base] = {
                    'name': name,
                    'price': None,
                    'error': 'Unavailable'
                }
                logger.warning(f"    âŒ Failed")
            
            time.sleep(2)
    
    logger.info("\n" + "="*60)
    logger.info("âœ… UPDATE COMPLETED")
    logger.info("="*60 + "\n")
    
    return all_data


# ===== FORMATTAZIONE =====
def format_message(data: Dict) -> str:
    parts = ["ğŸ“Š <b>AGGIORNAMENTO MERCATI</b>\n"]
    parts.append(f"ğŸ• {datetime.now().strftime('%d/%m/%Y %H:%M')}\n")
    
    for category, symbols in data.items():
        if category.startswith('_'):
            continue
        
        parts.append(f"\n<b>â”â”â” {category.upper()} â”â”â”</b>")
        
        for symbol, info in symbols.items():
            name = info.get('name', symbol)
            price = info.get('price')
            
            if price is None:
                parts.append(f"âšª {name}: <i>Non disponibile</i>")
                continue
            
            change_pct = info.get('change_percent', 0)
            emoji = "ğŸŸ¢" if change_pct > 0 else "ğŸ”´" if change_pct < 0 else "âšª"
            sign = "+" if change_pct > 0 else ""
            
            source = info.get('source', '')
            source_tag = f" <i>({source})</i>" if source else ""
            
            if price < 1:
                price_str = f"${price:.4f}"
            elif price < 100:
                price_str = f"${price:.2f}"
            else:
                price_str = f"${price:,.2f}"
            
            if change_pct != 0:
                parts.append(
                    f"{emoji} <b>{name}</b>{source_tag}\n"
                    f"   {price_str} ({sign}{change_pct:.2f}%)"
                )
            else:
                parts.append(f"{emoji} <b>{name}</b>{source_tag}\n   {price_str}")
    
    parts.append(f"\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
    parts.append(f"Prossimo aggiornamento: {UPDATE_INTERVAL_HOURS}h")
    parts.append("\n<i>ğŸ’¡ API: CoinGecko, ExchangeRate-API</i>")
    
    return "\n".join(parts)


# ===== COMANDI =====
async def cmd_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "ğŸ‘‹ <b>Market Bot (Hybrid Mode)</b>\n\n"
        "ğŸ”„ Usa API multiple per evitare rate limiting\n\n"
        "Comandi:\n"
        "/update - Aggiornamento immediato\n"
        "/status - Stato bot\n"
        "/markets - Lista mercati\n\n"
        f"â° Auto-update ogni {UPDATE_INTERVAL_HOURS}h",
        parse_mode='HTML'
    )


async def cmd_status(update: Update, context: ContextTypes.DEFAULT_TYPE):
    cache = load_cache()
    
    if is_cache_valid(cache):
        last = datetime.fromisoformat(cache['_last_update'])
        next_update = last + timedelta(hours=UPDATE_INTERVAL_HOURS)
        delta = next_update - datetime.now()
        
        h = int(delta.total_seconds() // 3600)
        m = int((delta.total_seconds() % 3600) // 60)
        
        msg = (
            f"âœ… <b>Bot Attivo (Hybrid Mode)</b>\n\n"
            f"ğŸ“… Ultimo: {last.strftime('%d/%m %H:%M')}\n"
            f"â° Prossimo: {h}h {m}m\n"
            f"ğŸ”„ Intervallo: {UPDATE_INTERVAL_HOURS}h\n\n"
            f"ğŸ’¡ API: CoinGecko + ExchangeRate"
        )
    else:
        msg = "âš ï¸ Cache non valida\nUsa /update"
    
    await update.message.reply_text(msg, parse_mode='HTML')


async def cmd_markets(update: Update, context: ContextTypes.DEFAULT_TYPE):
    parts = ["ğŸ“‹ <b>MERCATI MONITORATI</b>\n"]
    total = 0
    
    for cat, syms in MARKET_SYMBOLS.items():
        parts.append(f"\n<b>{cat}</b> ({len(syms)})")
        for sym, name in syms.items():
            parts.append(f"  â€¢ {name}")
            total += 1
    
    parts.append(f"\n<b>Totale: {total}</b>")
    parts.append("\n<i>ğŸ’¡ Nessun rate limiting Yahoo Finance!</i>")
    
    await update.message.reply_text("\n".join(parts), parse_mode='HTML')


async def cmd_update(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("ğŸ”„ Aggiornamento in corso...")
    
    try:
        data = update_all_markets()
        save_cache(data)
        msg = format_message(data)
        await update.message.reply_text(msg, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Update error: {e}")
        await update.message.reply_text(f"âŒ Errore: {str(e)[:200]}")


# ===== SCHEDULED =====
async def scheduled_update(context: ContextTypes.DEFAULT_TYPE):
    logger.info("\nâ° SCHEDULED UPDATE")
    
    try:
        cache = load_cache()
        if is_cache_valid(cache):
            logger.info("âœ… Cache valid, skipping")
            return
        
        logger.info("ğŸ”„ Starting update...")
        data = update_all_markets()
        save_cache(data)
        
        msg = format_message(data)
        await context.bot.send_message(chat_id=CHAT_ID, text=msg, parse_mode='HTML')
        
        logger.info("âœ… Update sent")
        
    except Exception as e:
        logger.error(f"âŒ Scheduled error: {e}")
        try:
            await context.bot.send_message(
                chat_id=CHAT_ID,
                text=f"âš ï¸ Errore: {str(e)[:200]}"
            )
        except:
            pass


# ===== MAIN =====
def main():
    logger.info("\n" + "="*60)
    logger.info("ğŸš€ HYBRID MARKET BOT STARTING")
    logger.info("="*60)
    logger.info("ğŸ’¡ Using: CoinGecko + ExchangeRate-API")
    logger.info("âœ… No Yahoo Finance = No Rate Limiting!")
    logger.info("="*60 + "\n")
    
    if not BOT_TOKEN or not CHAT_ID:
        logger.error("âŒ Missing BOT_TOKEN or CHAT_ID!")
        return
    
    logger.info(f"âœ… Token: {BOT_TOKEN[:10]}...")
    logger.info(f"âœ… Chat: {CHAT_ID}")
    logger.info(f"â±ï¸  Interval: {UPDATE_INTERVAL_HOURS}h")
    
    application = Application.builder().token(BOT_TOKEN).build()
    
    application.add_handler(CommandHandler("start", cmd_start))
    application.add_handler(CommandHandler("status", cmd_status))
    application.add_handler(CommandHandler("markets", cmd_markets))
    application.add_handler(CommandHandler("update", cmd_update))
    
    job_queue = application.job_queue
    job_queue.run_repeating(
        scheduled_update,
        interval=UPDATE_INTERVAL_HOURS * 3600,
        first=30
    )
    
    logger.info("âœ… Bot ready")
    logger.info("="*60 + "\n")
    
    # IMPORTANTE: drop_pending_updates per evitare conflitti
    application.run_polling(
        allowed_updates=Update.ALL_TYPES,
        drop_pending_updates=True
    )


if __name__ == '__main__':
    main()
